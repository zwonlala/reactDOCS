## Hook API Reference

### 기본 Hook

#### - useState
#### - useEffect
#### - useContext

<br>


### 추가 Hooks

#### - useReducer
#### - useCallback
#### - useMemo
#### - useRef
#### - useImperativaHandle
#### - useLayoutEffect
#### - useDebugValue

<br>
<br>


----

### 기본 Hook

### - useState

#### 함수적 갱신

값을 setState()에 주는 것이 아니라   
**"이전 state를 입력으로 받아, 새로운 state를 계산하는 함수"** 를  
setState()로 전달할 수 있음

#### 지연초기 state

초기 state가 고비용 계산의 결과라면,   
초기 렌더링 시에만 실행될 함수를 대신 제공 가능

```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

<br>
<br>

### - useEffect

#### effect 타이밍

componentDidMount, componentDidUpdate와 다르게
useEffect 로 전달된 함수는 지연 이벤트동안 '레이아웃 배치' + '그리기' 완료한 후 발생
(지연됨)

~> 만약 지연되지 않고 화면을 다 그리기 전에 동기화 되어야 하는 경우에는 useLayoutEffect 사용


#### 조건부 effect 발생

useEffect의 기본 동작은 모든 렌더링을 완료한 후 effect를 발생.  
-> 의존하는 값 중 한 값이라도 변경되면 effect는 항상 재생성됨.

<br>

만약 해당 작업을 최적화하고 싶다면(조건부 effect 생성),

useEffect의 두번째 인자로, 의존하는 값으로 이루어진 배열 리턴

<br>

만약 `[]` 빈 배열을 두번째 인자로 사용한다면,

- mount 할 때
- unmount 할 때

한 번씩 총 두번 만 실행함 (like _componentDidMount_, _comonentDidUnmount_)  
(∵ effect 함수가 어떤 값에도 의존하지 않으므로, 다시 실행할 필요가 없다)


주의) 최적화 하는 경우,   
'effect에 사용되는 컴포넌트 안의 모든 값을 포함하고 있는지 확인'  
-> 만약 아니라면 이전 렌더링에 설정된 오래된 값을 참조할 수 있음

<br>
<br>

### - useContext

```
const value = useContext(MyContext);
```

context 객체를 받아,
그 context의 현재 값을 반환하는 Hook

context의 현재 값은 useContext Hook을 호출하는 컴포넌트에 가장 가까이 있는
<MyContext.Provider> 의 value prop에 의해 결정됨.

<br>

가장 가까이 있는 <MyContext.Provider>이 갱신되면

useContext Hook은 전달된 가장 최신의 context의 value를 사용하여 렌더러를 트리거

<br>

useContext로 전달한 인자는 context 인자 그 자체여야 함.

<br>
<br>
<br>
<br>

----

### 추가 Hooks

### - useReducer

<br>
<br>

### - useCallback

<br>
<br>

### - useMemo

<br>
<br>

### - useRef

<br>
<br>

### - useImperativaHandle

<br>
<br>

### - useLayoutEffect

<br>
<br>

### - useDebugValue


<br>
<br>
<br>
<br>
