## 이펙트 Hook 사용하기


이펙트 훅 사용하면 함수형 컴포넌트에서도 사이드 이펙트 수행 가능

사이드 이펙트스
- 데이터 패칭
- 구독 설정
- 수동으로 리액트 컴포넌트의 돔 수정.  

```
유즈이펙트 훅 = 클래스 컴포넌트의 컴포넌트디드마운트 
	   + 클래스 컴포넌트의 컴포넌트디드업데이트()
	   + 클래스 컴포넌트의 컴포넌트윌언마운트()
```

리엑트의 사이드 이펙트에는 2가지 종류가 있다

1. 클린업(정리) 필요
2. 클린업 필요 ㅌ


### 정리(클린-업)을 이용하지 않는 이펙트스

리액트가 돔 업데이트 후 부가적인 코드를 실행해야 하는 경우 ㅒ

- 네트워크 리퀘스트
- 돔 수동조작
- 로깅

위의 경우가 클린-업 필요없는 경우
(∵ 실행 이후 신경 쓸게 ㅌ)

<br>

#### `유즈이펙트` 가 하는 일

	- 유즈이펙트 훅을 이용하여 리엑트에게 컴포넌트라 렌더링 이후에 '어떤 일을 수행해야 하는지' 말함
		- '어떤 일을 수행해야 하는지' = effect 함수
	- 리엑트는 이펙트 함수를 기억하고 있다가 돔 업데이트를 수행한 이후에 호출함

<br>

#### `유즈이펙트`를 컴포넌트 내부에서 호출하는 이유?

	이펙트 함수에서
	- 스테이트 변수 값
	- 프롭스 값
	에 접근할 수 ㅒ

	=> JS의 클로져를 이용하여 문제를 해결!

<br>

#### `유즈이펙트`는 렌더링 이후에 매번 수행?

	- 첫번째 렌더링과 이후의 모든 업데이트 시 수행
	  - 마운팅
	  - 업데이트 라는
	  방식으로 나누어 이해하는 것이 아닌  
	  이펙트를 렌더링 이후에 발생하는 것이라고 생각!
	- 리액트는 이펙트가 수행되는 시점에 이미 돔이 업데이트 되었음을 보장

<br>
<br>

### ???

<>

같은 함수 내부에 있기 때문에 최신의 카운트로 아고? 받을 수 ㅒ

컴포넌트 렌더링할때 리엑트는 이펙트 함수 기억하고 있다가

돔을 업데이트 한 이후 이펙트 함수 실행
~> 첫번째 렌더링 포함 모든 렌더링에 똑같이 적용

+ㅁ) 유즈 이펙트()에 전달된 이펙트 함수가 모든 렌더링에서 다르다!
(∵ 익명함수)

=> 의도된 부분으로 카운트 값이 제대로 업데이트 되는지에 대해 걱정할 필요 ㅌ
이펙트 내부에서 그 값을 읽을 수 있게 하는 부분

리렌더링 시 모두 이전과다른 이펙트 함수로 교체하여 전달


팁> 유즈이펙트에서 사용되는 이펙트 함수는 브라우져가 화면을 업데이트 하는 것을 차단하지 ㅌ

- 대부분의 이펙트는 동기적으로 실행될 필요가 ㅌ
- 동기적으로 실행(Ex/ 레이아웃 측정)이 필요한 상황에서는 유즈레이아웃이펙트() 사용!

[x, setX] 와 같은 쌍으로 state 변수 선언하는 것 유용

여러개의 state 변수를 사용하지 않아도 됨 (state 변수에 객체, 배열 할당 가능)

클래스 컴포넌트의 this.setState()와 달리
state를 갱신하는 것은 _병합_ 하는 것이 아닌 **대체**하는 것

<br>
<br>
<br>
<br>
